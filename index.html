<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Moonbound: Echoes of the Ashen Crown</title>
<style>
  :root{--bg:#05060a;--panel:#0d1014;--accent:#b77a3a;--muted:#9aa0aa;--dialog:#0b1220;--danger:#c14242;--success:#4a9c2d;--purple:#8a4fbe;--gold:#d4924a}
  body{margin:0;font-family:Georgia,serif;background:linear-gradient(180deg,#02040a 0%, #08121a 100%);color:#efece6;font-size:14px}
  
  /* Main Menu Styles */
  .main-menu{
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    min-height:100vh;
    background:linear-gradient(135deg, #1a1530 0%, #2a1845 40%, #0a0a15 100%);
    position:relative;
    overflow:hidden;
  }
  
  .title-section{
    text-align:center;
    margin-bottom:50px;
    z-index:10;
  }
  
  .game-title{
    font-size:48px;
    font-weight:700;
    color:#ffffff;
    text-shadow: 
      0 0 30px rgba(183, 122, 58, 0.7),
      0 0 50px rgba(100, 100, 100, 0.5),
      2px 2px 6px rgba(0, 0, 0, 0.8);
    margin-bottom:10px;
    animation:titlePulse 4s ease-in-out infinite;
  }
  
  .game-subtitle{
    font-size:20px;
    color:rgba(183, 122, 58, 0.8);
    font-style:italic;
    letter-spacing:2px;
    text-shadow:0 0 15px rgba(183, 122, 58, 0.4);
  }
  
  .menu-buttons{
    display:flex;
    flex-direction:column;
    gap:15px;
    min-width:300px;
  }
  
  .menu-btn{
    background:linear-gradient(135deg, var(--accent) 0%, var(--gold) 100%);
    border:none;
    padding:15px 25px;
    border-radius:12px;
    color:#241305;
    font-weight:700;
    font-size:16px;
    cursor:pointer;
    transition:all 0.3s;
    box-shadow:0 5px 15px rgba(183,122,58,0.3);
    text-shadow:none;
  }
  
  .menu-btn:hover{
    transform:translateY(-2px);
    box-shadow:0 8px 25px rgba(183,122,58,0.5);
    background:linear-gradient(135deg, var(--gold) 0%, #e6a355 100%);
  }
  
  .menu-btn:disabled{
    background:#666;
    color:#999;
    cursor:not-allowed;
    transform:none;
    box-shadow:none;
  }
  
  .background-effects{
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    opacity:0.2;
    pointer-events:none;
  }
  
  .floating-symbols{
    position:absolute;
    width:100%;
    height:100%;
  }
  
  .symbol{
    position:absolute;
    color:rgba(255, 215, 0, 0.6);
    font-size:24px;
    animation:floatSymbol 15s ease-in-out infinite;
  }
  
  @keyframes titlePulse{
    0%, 100% { 
      text-shadow: 
        0 0 30px rgba(183, 122, 58, 0.7),
        0 0 50px rgba(100, 100, 100, 0.5),
        2px 2px 6px rgba(0, 0, 0, 0.8);
    }
    50% { 
      text-shadow: 
        0 0 40px rgba(183, 122, 58, 0.9),
        0 0 60px rgba(120, 120, 120, 0.7),
        2px 2px 6px rgba(0, 0, 0, 0.8);
    }
  }
  
  @keyframes floatSymbol{
    0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.6; }
    25% { transform: translateY(-25px) rotate(8deg); opacity: 0.8; }
    50% { transform: translateY(-15px) rotate(-5deg); opacity: 0.4; }
    75% { transform: translateY(-35px) rotate(12deg); opacity: 0.7; }
  }
  
  /* Game UI Styles */
  .game-container{display:none}
  .app{display:grid;grid-template-columns:400px 1fr 420px;gap:12px;padding:12px;min-height:100vh}
  .panel{background:var(--panel);padding:16px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.7);border:1px solid rgba(183,122,58,0.1)}
  h1{margin:0 0 8px;font-size:20px;color:var(--accent);text-shadow:0 2px 4px rgba(0,0,0,0.8)}
  h2{margin:12px 0 6px;font-size:16px;color:#d4c4a8}
  .small{font-size:13px;color:var(--muted);line-height:1.4}
  .lore{font-style:italic;color:#c4a773;background:rgba(196,163,115,0.1);padding:10px;border-radius:8px;margin:8px 0;border-left:3px solid var(--accent)}
  button{background:var(--accent);border:none;padding:10px 14px;border-radius:8px;color:#241305;font-weight:700;cursor:pointer;transition:all 0.2s}
  button:hover{background:#d4924a;transform:translateY(-1px)}
  button:disabled{background:#666;color:#999;cursor:not-allowed;transform:none}
  .stat{display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.05)}
  .stat:last-child{border-bottom:none}
  .upgrades{display:flex;flex-direction:column;gap:10px}
  .upgrade{display:flex;justify-content:space-between;padding:12px;background:rgba(255,255,255,0.03);border-radius:10px;border:1px solid rgba(255,255,255,0.05)}
  .dungeon-map{background:#071017;padding:12px;border-radius:10px;min-height:240px;border:1px solid rgba(255,255,255,0.1)}
  .node{padding:12px;margin:8px;border-radius:10px;background:rgba(255,255,255,0.03);cursor:pointer;transition:all 0.2s;border:1px solid rgba(255,255,255,0.05)}
  .node:hover{background:rgba(183,122,58,0.1);transform:translateY(-2px)}
  .node.locked{opacity:0.4;cursor:not-allowed}
  .node.locked:hover{transform:none;background:rgba(255,255,255,0.03)}
  .node.completed{border: 2px solid var(--accent); opacity: 0.7;}
  .node.current{border: 2px solid var(--gold); background:rgba(212,146,74,0.1);}
  .card{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.05)}
  .dialogue{background:var(--dialog);padding:18px;border-radius:14px;margin-top:12px;min-height:140px;border:1px solid rgba(255,255,255,0.1)}
  .choices{display:flex;flex-direction:column;gap:10px;margin-top:12px}
  .hp{font-weight:700}
  .hp.dead{color:var(--danger)}
  .hp.injured{color:#ff9500}
  .hp.healthy{color:var(--success)}
  .right-col{display:flex;flex-direction:column;gap:10px}
  .inventory-list{min-height:100px; max-height:160px;overflow:auto; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;}
  .log{height:200px;overflow:auto;background:#07131a;padding:10px;border-radius:10px;font-size:12px;border:1px solid rgba(255,255,255,0.1)}
  .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .small-muted{font-size:12px;color:#9b9b9b}
  .chronicle{background:rgba(196,163,115,0.05);padding:12px;border-radius:8px;margin:10px 0;border-left:2px solid var(--accent)}
  .legacy-title{color:var(--purple);text-shadow:0 0 10px rgba(138,79,190,0.5)}
  .tooltip { position: relative; display: inline-block; }
  .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: #111; color: #fff; text-align: left; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 12px; line-height: 1.5;}
  .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
  .trait-tag { background: #3a3a3a; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin: 2px; display: inline-block; }
  .status-effect { font-weight: bold; padding: 1px 4px; border-radius: 3px; font-size: 10px; }
  .status-poison { color: #90ee90; background: rgba(144, 238, 144, 0.2); }
  .status-stunned { color: #add8e6; background: rgba(173, 216, 230, 0.2); }
  .status-weakened { color: #f0e68c; background: rgba(240, 230, 140, 0.2); }
  .status-bleeding { color: #ff6b6b; background: rgba(255, 107, 107, 0.2); }
  .status-shielded { color: #87ceeb; background: rgba(135, 206, 235, 0.2); }
  
  .event-card{
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 10px;
    padding: 16px;
    margin: 10px 0;
  }
  
  .legacy-upgrades {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-top: 10px;
  }
  
  .legacy-upgrade {
    background: rgba(138, 79, 190, 0.1);
    border: 1px solid rgba(138, 79, 190, 0.3);
    border-radius: 8px;
    padding: 10px;
    text-align: center;
  }
  
  .purple {
    background: var(--purple) !important;
    color: white !important;
  }
  
  .purple:hover {
    background: #9a5bc7 !important;
  }
  
  .info { color: #87ceeb; }
  .success { color: var(--success); }
  .danger { color: var(--danger); }
  .warning { color: #ff9500; }
  
  /* Responsive design */
  @media (max-width: 1200px) {
    .app {
      grid-template-columns: 350px 1fr 350px;
    }
  }
  
  @media (max-width: 900px) {
    .app {
      grid-template-columns: 1fr;
      gap: 8px;
    }
    
    .panel {
      padding: 12px;
    }
    
    .game-title {
      font-size: 36px;
    }
    
    .menu-buttons {
      min-width: 250px;
    }
  }

</style>
</head>
<body>

<!-- Main Menu -->
<div class="main-menu" id="mainMenu">
  <div class="background-effects">
    <div class="floating-symbols">
      <div class="symbol" style="top:10%;left:15%;animation-delay:0s">‚ôÖ</div>
      <div class="symbol" style="top:20%;right:20%;animation-delay:2s">‚ôÑ</div>
      <div class="symbol" style="top:60%;left:10%;animation-delay:4s">‚ôÉ</div>
      <div class="symbol" style="top:70%;right:15%;animation-delay:6s">‚ôÜ</div>
      <div class="symbol" style="top:30%;left:60%;animation-delay:8s">‚ôá</div>
      <div class="symbol" style="bottom:20%;right:60%;animation-delay:10s">‚ôÉ</div>
    </div>
  </div>
  
  <div class="title-section">
    <h1 class="game-title">Moonbound</h1>
    <div class="game-subtitle">Echoes of the Ashen Crown</div>
  </div>
  
  <div class="menu-buttons">
    <button class="menu-btn" onclick="startNewGame()">üìú Begin New Chronicle</button>
    <button class="menu-btn" onclick="loadGame()" id="loadBtn">üìñ Continue Chronicle</button>
    <button class="menu-btn" onclick="showHelp()">‚ùì How to Play</button>
  </div>
</div>

<!-- Game Container -->
<div class="game-container" id="gameContainer">
  <div class="app">
    <div class="panel">
      <h1>üïØÔ∏è The Chronicler's Scriptorium</h1>
      <div class="lore">
        The world is caught in a loop, endlessly dying and rebirthing under the curse of the Ashen Crown. You are the Chronicler, a being outside this cycle, tasked with recording its history and guiding heroes to break the curse.
      </div>
      
      <div class="small">
        <strong>Cycle Number:</strong> <span id="loops">1</span><br>
        <strong>Legacy Power:</strong> <span id="crownFragments">0</span> Crown Fragments<br>
        <strong>Chronicle Progress:</strong> <span id="chronicleProgress">0%</span>
      </div>
      
      <hr style="margin:12px 0;border:none;height:1px;background:rgba(255,255,255,0.1)">
      
      <div id="stats">
        <div class="stat"><div>‚úíÔ∏è Temporal Essence</div><div id="essence">0</div></div>
        <div class="stat"><div>üìú Lore Scraps</div><div id="loreScraps">0</div></div>
        <div class="stat"><div>‚öîÔ∏è Champions Guided</div><div id="champions">0</div></div>
        <div class="stat"><div>üèÜ Victories</div><div id="victories">0</div></div>
      </div>
      
      <hr style="margin:12px 0;border:none;height:1px;background:rgba(255,255,255,0.1)">
      
      <h2>Chronicler's Arts</h2>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px">
        <button id="gather">‚úíÔ∏è Chronicle Events</button>
        <button id="recruit">ü§ù Find a Champion</button>
      </div>
      
      <div style="margin-top:12px">
        <h2>Scriptorium Upgrades</h2>
        <div class="upgrades" id="upgrades"></div>
      </div>

      <div style="margin-top:12px">
        <h2 class="legacy-title">üëë Legacy Upgrades</h2>
        <div class="small">Permanent improvements powered by Crown Fragments</div>
        <div class="legacy-upgrades" id="legacyUpgrades"></div>
      </div>

      <div style="margin-top:12px" class="controls">
        <button id="saveBtn">üíæ Save</button>
        <button id="exportBtn">üì§ Export</button>
        <button id="importBtn">üì• Import</button>
        <button id="menuBtn">üè† Main Menu</button>
      </div>

      <div style="margin-top:16px">
        <button id="prestige" class="purple" style="width:100%;padding:14px">
          üëë Shatter the Crown
        </button>
        <div class="small" style="margin-top:6px">
          Confront the source of the curse. This will end the current cycle, but the echoes of your success will empower the next.
        </div>
      </div>
    </div>

    <div class="panel">
      <h1>üó∫Ô∏è The Cursed Lands</h1>
      <div class="lore">
        Each journey through these lands is a new verse in the same tragic epic. Choose your path wisely, Chronicler. The fate of this cycle rests on the choices made by you and your champion.
      </div>
      
      <div class="chronicle" id="currentChronicle">
        <strong>Current Chronicle:</strong> <span id="chronicleText">The ink is still wet on the first page...</span>
      </div>
      
      <div class="dungeon-map" id="dungeonMap"></div>

      <div id="eventDialog" style="display:none" class="event-card">
        <div id="eventText"></div>
        <div class="choices" id="eventChoices"></div>
      </div>

      <hr style="margin:12px 0;border:none;height:1px;background:rgba(255,255,255,0.1)">
      
      <h2>‚öîÔ∏è Active Encounter</h2>
      <div id="encounterArea">
        <div id="encounterInfo" class="small">The path ahead is quiet... for now.</div>
        <div id="battleUI" style="display:none;margin-top:12px">
          <div style="margin-top:12px">
            <strong style="color:var(--danger)" id="enemyName"></strong>
          </div>
          <div id="enemyCard" class="card small"></div>
          <div class="actions" id="battleActions" style="margin-top:12px"></div>
        </div>
      </div>
      
      <h2>üìú Event Log</h2>
      <div class="log" id="eventLog"></div>
    </div>

    <div class="panel right-col">
      <h1>‚ù§Ô∏è Champion's Status</h1>
       <div id="roster"></div>
      
      <hr style="margin:12px 0;border:none;height:1px;background:rgba(255,255,255,0.1)">
      
      <h2>üéí Inventory</h2>
      <div class="small">Items found on your journey. Click to use in combat.</div>
      <div class="inventory-list" id="inventory"></div>
      
       <hr style="margin:12px 0;border:none;height:1px;background:rgba(255,255,255,0.1)">
      
      <h2>üìñ Discovered Lore</h2>
      <div class="small" id="loreEntries" style="max-height: 200px; overflow-y: auto;">
        Discover lore scraps to piece together the world's history...
      </div>
    </div>
  </div>
</div>

<script>
// --- STATE MANAGEMENT ---
let state;

function getNewGameState() {
    return {
        essence: 0,
        loreScraps: 0,
        loops: 1,
        crownFragments: 0,
        victories: 0,
        essencePerClick: 1,
        essencePerSec: 0,
        recruitCost: 10,
        upgrades: [
            {id: 'quill', name: 'Flowing Quill', cost: 50, desc: 'Your writing becomes swifter. +1 Essence per second.', bought: false, apply: () => state.essencePerSec += 1},
            {id: 'library', name: 'Expand Library', cost: 200, desc: 'Better research. Champions start with +10 Max HP.', bought: false, apply: () => {}},
            {id: 'scrying', name: 'Scrying Pool', cost: 500, desc: 'Glimpse the future. See enemy HP in combat.', bought: false, apply: () => {}},
            {id: 'binding', name: 'Tome Binding', cost: 1200, desc: 'Preserve knowledge. Gain +1 Lore Scrap per victory.', bought: false, apply: () => {}},
            {id: 'mastery', name: 'Chronicle Mastery', cost: 3000, desc: 'Deep understanding. +2 Essence per click and +2 per second.', bought: false, apply: () => { state.essencePerClick += 2; state.essencePerSec += 2; }},
            {id: 'wisdom', name: 'Ancient Wisdom', cost: 8000, desc: 'Champions gain experience 50% faster and unlock advanced skills.', bought: false, apply: () => {}},
        ],
        legacyUpgrades: {
            damage: { level: 0, cost: 1, name: 'Heroic Might', desc: 'Champions deal +20% damage per level.' },
            health: { level: 0, cost: 1, name: 'Vital Force', desc: 'Champions have +15 Max HP per level.' },
            essence: { level: 0, cost: 2, name: 'Temporal Mastery', desc: 'Gain +1 Essence per second per level.' },
            lore: { level: 0, cost: 3, name: 'Chronicle Keeper', desc: '+1 Lore Scrap per victory per level.' },
        },
        roster: [],
        inventory: [],
        dungeon: { map: [], currentNode: null, floor: 1 },
        activeEncounter: null,
        loreUnlocked: [],
        activeEvent: null,
        championExperience: 0,
    };
}

// --- DATA ---
const championArchetypes = [
    {
        id: 'knight', name: 'The Steadfast Knight',
        lore: 'A forgotten knight, bound by an oath to protect a kingdom that has turned to dust.',
        hp: 100, maxHp: 100, resolve: 50, maxResolve: 50,
        experience: 0, level: 1,
        skills: [
            { name: 'Shield Bash', cost: 20, desc: 'Deal 15 damage and Stun the enemy for 2 turns.', effect(enemy, user) { 
                let damage = 15 + (user.level - 1) * 3;
                enemy.hp -= damage; 
                applyStatus(enemy, 'stunned', 2); 
                log(`${user.name} deals ${damage} damage and stuns the enemy!`);
            }},
            { name: 'Valiant Strike', cost: 10, desc: 'A reliable attack that grows stronger with experience.', effect(enemy, user) { 
                let damage = 10 + (user.level - 1) * 2;
                enemy.hp -= damage;
                log(`${user.name} deals ${damage} damage!`);
            }},
            { name: 'Hold the Line', cost: 0, desc: 'Recover Resolve and gain Shield for 3 turns.', effect(enemy, user) { 
                user.resolve += 15; 
                applyStatus(user, 'shielded', 3);
                log(`${user.name} recovers resolve and raises their shield!`);
            }}
        ],
        bond: 0, maxBond: 100, traits: ['Stalwart', 'Protective']
    },
    {
        id: 'ranger', name: 'The Wary Ranger',
        lore: 'A hunter who stalks the cursed woods, knowing the name of every beast and every ghost.',
        hp: 80, maxHp: 80, resolve: 60, maxResolve: 60,
        experience: 0, level: 1,
        skills: [
            { name: 'Venom Arrow', cost: 15, desc: 'Deal damage and apply Poison for 4 turns.', effect(enemy, user) { 
                let damage = 5 + Math.floor((user.level - 1) * 1.5);
                enemy.hp -= damage; 
                applyStatus(enemy, 'poison', 4); 
                log(`${user.name} shoots a poisoned arrow for ${damage} damage!`);
            }},
            { name: 'Aimed Shot', cost: 25, desc: 'A carefully aimed shot that increases in power.', effect(enemy, user) { 
                let damage = 25 + (user.level - 1) * 4;
                enemy.hp -= damage;
                log(`${user.name} lands a precise shot for ${damage} damage!`);
            }},
            { name: 'Recuperate', cost: 0, desc: 'Forage for herbs, recovering HP and curing status effects.', effect(enemy, user) { 
                let healing = 15 + (user.level - 1) * 3;
                user.hp = Math.min(user.maxHp, user.hp + healing); 
                user.statusEffects = user.statusEffects?.filter(s => s.type === 'shielded') || [];
                log(`${user.name} recovers ${healing} HP and clears debuffs!`);
            }}
        ],
        bond: 0, maxBond: 100, traits: ['Swift', 'Keen-Eyed']
    },
    {
        id: 'mage', name: 'The Exiled Scholar',
        lore: 'Once a court wizard, now a wanderer seeking redemption through forbidden knowledge.',
        hp: 60, maxHp: 60, resolve: 80, maxResolve: 80,
        experience: 0, level: 1,
        skills: [
            { name: 'Arcane Bolt', cost: 12, desc: 'Launch magical energy that pierces defenses.', effect(enemy, user) { 
                let damage = 12 + (user.level - 1) * 3;
                enemy.hp -= damage;
                log(`${user.name} casts Arcane Bolt for ${damage} damage!`);
            }},
            { name: 'Weaken', cost: 18, desc: 'Curse the enemy, reducing their damage for 4 turns.', effect(enemy, user) { 
                applyStatus(enemy, 'weakened', 4);
                log(`${user.name} hexes the enemy, weakening their attacks!`);
            }},
            { name: 'Meditate', cost: 0, desc: 'Focus magical energy, recovering Resolve.', effect(enemy, user) { 
                let recovery = 20 + (user.level - 1) * 3;
                user.resolve = Math.min(user.maxResolve, user.resolve + recovery);
                log(`${user.name} meditates and recovers ${recovery} Resolve!`);
            }}
        ],
        bond: 0, maxBond: 100, traits: ['Scholarly', 'Mystic']
    }
];

const enemies = {
    'husk': { 
        name: 'Ashen Husk', hp: 50, maxHp: 50, atk: 8, 
        skills: [
            { type: 'attack', desc: 'A shambling attack' },
            { type: 'special', desc: 'Drain life', effect(target) { 
                let damage = 5;
                target.hp -= damage; 
                this.hp = Math.min(this.maxHp, this.hp + Math.floor(damage/2));
                log(`${this.name} drains ${damage} life from ${target.name}!`, 'danger'); 
            }}
        ],
        statusEffects: []
    },
    'wight': { 
        name: 'Sorrow Wight', hp: 70, maxHp: 70, atk: 12, 
        skills: [
            { type: 'attack', desc: 'Spectral claws' },
            { type: 'special', desc: 'Despair aura', effect(target) { 
                target.resolve -= 15; 
                applyStatus(target, 'weakened', 2);
                log(`${this.name} emanates despair, draining will and strength!`, 'danger'); 
            }}
        ],
        statusEffects: []
    },
    'echo': { 
        name: 'Crown\'s Echo', hp: 120, maxHp: 120, atk: 18, 
        skills: [
            { type: 'attack', desc: 'Crushing blow' },
            { type: 'special', desc: 'Curse of ages', effect(target) { 
                applyStatus(target, 'bleeding', 3);
                applyStatus(target, 'weakened', 3);
                log(`${this.name} inflicts ancient curses!`, 'danger'); 
            }},
            { type: 'special', desc: 'Royal command', effect(target) { 
                let damage = 25;
                target.hp -= damage;
                target.resolve -= 20;
                log(`${this.name} commands obedience, dealing ${damage} damage and draining resolve!`, 'danger'); 
            }}
        ],
        statusEffects: []
    },
    'sentinel': {
        name: 'Stone Sentinel', hp: 90, maxHp: 90, atk: 15,
        skills: [
            { type: 'attack', desc: 'Boulder strike' },
            { type: 'special', desc: 'Fortify', effect(target) {
                applyStatus(this, 'shielded', 3);
                log(`${this.name} hardens its defenses!`, 'info');
            }}
        ],
        statusEffects: []
    }
};

const items = {
    'potion': { 
        name: 'Healing Potion', desc: 'Recovers 30 HP instantly.', 
        use(target) { 
            let healing = 30;
            target.hp = Math.min(target.maxHp, target.hp + healing); 
            log(`${target.name} drinks a Healing Potion, recovering ${healing} HP.`, 'success'); 
        }
    },
    'draught': { 
        name: 'Resolve Draught', desc: 'Recovers 25 Resolve instantly.', 
        use(target) { 
            let recovery = 25;
            target.resolve = Math.min(target.maxResolve, target.resolve + recovery); 
            log(`${target.name} drinks a Resolve Draught, recovering ${recovery} Resolve.`, 'success'); 
        }
    },
    'elixir': {
        name: 'Elixir of Fortitude', desc: 'Grants Shield status for 5 turns.',
        use(target) {
            applyStatus(target, 'shielded', 5);
            log(`${target.name} drinks an Elixir of Fortitude, gaining protection!`, 'success');
        }
    },
    'antidote': {
        name: 'Antidote Vial', desc: 'Removes all negative status effects.',
        use(target) {
            let removed = target.statusEffects?.filter(s => ['poison', 'bleeding', 'weakened', 'stunned'].includes(s.type)) || [];
            target.statusEffects = target.statusEffects?.filter(s => !['poison', 'bleeding', 'weakened', 'stunned'].includes(s.type)) || [];
            log(`${target.name} uses an Antidote Vial, clearing ${removed.length} debuffs!`, 'success');
        }
    },
    'bomb': {
        name: 'Alchemical Bomb', desc: 'Deals 40 damage to the enemy.',
        use(target, enemy) {
            if (enemy) {
                let damage = 40;
                enemy.hp -= damage;
                log(`${target.name} throws an Alchemical Bomb, dealing ${damage} damage!`, 'success');
            }
        }
    }
};

const randomEvents = [
    {
        id: 'merchant',
        title: 'Wandering Merchant',
        text: 'A hooded figure approaches with a cart full of mysterious wares. Their goods shimmer with otherworldly energy.',
        choices: [
            { text: 'Trade 30 Essence for a random item', cost: { essence: 30 }, reward: { item: 'random' } },
            { text: 'Trade 50 Essence for a healing item', cost: { essence: 50 }, reward: { item: 'potion' } },
            { text: 'Politely decline', reward: { essence: 5 } }
        ]
    },
    {
        id: 'shrine',
        title: 'Ancient Shrine',
        text: 'You discover a crumbling shrine dedicated to forgotten gods. Ancient runes pulse with fading power.',
        choices: [
            { text: 'Offer 20 Essence in prayer', cost: { essence: 20 }, reward: { championHeal: 0.3, lore: 1 } },
            { text: 'Study the runes carefully', reward: { lore: 2, essence: 10 } },
            { text: 'Leave it undisturbed', reward: {} }
        ]
    },
    {
        id: 'memory',
        title: 'Echoing Memory',
        text: 'The air shimmers, and you witness a ghostly reenactment of past events. The memory speaks of hidden knowledge.',
        choices: [
            { text: 'Focus on the memory intently', cost: { resolve: 15 }, reward: { lore: 3, essence: 20 } },
            { text: 'Let the memory pass naturally', reward: { lore: 1 } }
        ]
    },
    {
        id: 'training',
        title: 'Sparring Grounds',
        text: 'Your champion finds ancient training dummies that seem to move on their own, offering a chance to hone their skills.',
        choices: [
            { text: 'Train intensively', cost: { resolve: 20 }, reward: { experience: 25 } },
            { text: 'Practice basic forms', reward: { experience: 10, resolve: 5 } },
            { text: 'Rest instead', reward: { championHeal: 0.2 } }
        ]
    }
];

// --- DOM ELEMENTS ---
const elements = {};
document.addEventListener('DOMContentLoaded', () => {
    const ids = ['mainMenu', 'gameContainer', 'essence', 'loreScraps', 'champions', 'loops', 'crownFragments', 'victories',
                 'upgrades', 'legacyUpgrades', 'roster', 'inventory', 'dungeonMap', 'battleUI', 'encounterInfo', 'enemyCard',
                 'enemyName', 'battleActions', 'eventLog', 'currentChronicle', 'chronicleText', 'chronicleProgress', 
                 'loreEntries', 'loadBtn', 'eventDialog', 'eventText', 'eventChoices'];
    ids.forEach(id => elements[id] = document.getElementById(id));
    
    // Event Listeners
    document.getElementById('gather').addEventListener('click', gather);
    document.getElementById('recruit').addEventListener('click', recruit);
    document.getElementById('saveBtn').addEventListener('click', saveGame);
    document.getElementById('exportBtn').addEventListener('click', exportData);
    document.getElementById('importBtn').addEventListener('click', importData);
    document.getElementById('menuBtn').addEventListener('click', showMainMenu);
    document.getElementById('prestige').addEventListener('click', prestige);

    if (!localStorage.getItem('moonbound_save')) {
        elements.loadBtn.disabled = true;
    }

    // Start game logic after DOM is fully loaded
    state = getNewGameState();
    initGame();

    // Start the main loop *after* the DOM is ready.
    setInterval(() => {
        if (state && elements.gameContainer.style.display === 'block') {
            if (state.essencePerSec > 0) {
                state.essence += state.essencePerSec;
            }
            // Random events
            if (state.roster.length > 0 && !state.activeEncounter && !state.activeEvent && Math.random() < 0.002) {
                triggerRandomEvent();
            }
            updateAllUI();
        }
    }, 1000);
});

// --- UI UPDATE FUNCTIONS ---
function updateAllUI() {
    if (!state || !elements.essence) {
        console.warn('State or elements not properly initialized');
        return;
    }
    
    elements.essence.textContent = Math.floor(state.essence).toLocaleString();
    elements.loreScraps.textContent = state.loreScraps.toLocaleString();
    elements.champions.textContent = state.roster.length > 0 ? '1/1' : '0/1';
    elements.loops.textContent = state.loops.toLocaleString();
    elements.crownFragments.textContent = state.crownFragments.toLocaleString();
    elements.victories.textContent = state.victories.toLocaleString();
    
    // Calculate progress
    let progress = 0;
    if (state.dungeon.map.length > 0) {
        const completed = state.dungeon.map.filter(n => n.completed).length;
        progress = Math.floor((completed / state.dungeon.map.length) * 100);
    }
    if (elements.chronicleProgress) {
        elements.chronicleProgress.textContent = progress + '%';
    }
    
    updateUpgradesUI();
    updateLegacyUpgradesUI();
    updateRosterUI();
    updateInventoryUI();
    updateDungeonMapUI();
    updateBattleUI();
    updateLoreUI();
    updateChronicleUI();

    document.getElementById('recruit').disabled = state.roster.length > 0 || state.essence < state.recruitCost;
    document.getElementById('recruit').textContent = `ü§ù Find a Champion (${state.recruitCost}‚úíÔ∏è)`;
    
    document.getElementById('prestige').disabled = !canPrestige();
}

function updateRosterUI() {
    elements.roster.innerHTML = '';
    if (state.roster.length === 0) {
        elements.roster.innerHTML = `<div class="card small-muted">No champion has been found for this cycle.</div>`;
        return;
    }
    
    const char = state.roster[0];
    const hpClass = char.hp <= 0 ? 'dead' : char.hp < char.maxHp * 0.5 ? 'injured' : 'healthy';
    const expToNext = char.level * 100;
    const expProgress = Math.floor((char.experience % 100) / 100 * 100);
    
    let skillsHTML = '';
    char.skills.forEach(skill => {
        skillsHTML += `<div class="tooltip small">
            - ${skill.name} (${skill.cost} Res)
            <span class="tooltiptext">${skill.desc}</span>
        </div>`;
    });

    let statusHTML = '';
    if (char.statusEffects && char.statusEffects.length > 0) {
        char.statusEffects.forEach(s => {
            statusHTML += `<span class="status-effect status-${s.type}">${s.type.toUpperCase()} (${s.duration})</span> `;
        });
    }

    let traitsHTML = '';
    char.traits.forEach(trait => {
        traitsHTML += `<span class="trait-tag">${trait}</span>`;
    });

    elements.roster.innerHTML = `
        <div class="card">
            <strong>${char.name} (Level ${char.level})</strong>
            <div class="small-muted">${char.lore}</div>
            <div class="stat"><div>HP</div><div class="hp ${hpClass}">${char.hp}/${char.maxHp}</div></div>
            <div class="stat"><div>Resolve</div><div>${char.resolve}/${char.maxResolve}</div></div>
            <div class="stat"><div>Experience</div><div>${char.experience} (${expProgress}%)</div></div>
            <div class="stat"><div>Bond</div><div>${char.bond}/${char.maxBond}</div></div>
            ${statusHTML ? `<div class="small" style="margin: 5px 0;">${statusHTML}</div>` : ''}
            <div style="margin: 5px 0;">${traitsHTML}</div>
            <h2>Skills</h2>
            ${skillsHTML}
        </div>`;
}

function updateInventoryUI() {
    elements.inventory.innerHTML = '';
    if (state.inventory.length === 0) {
        elements.inventory.innerHTML = `<div class="small-muted" style="grid-column: 1 / 3;">Your satchel is empty.</div>`;
        return;
    }
    state.inventory.forEach((item, index) => {
        const itemData = items[item.id];
        const itemEl = document.createElement('div');
        itemEl.className = 'card small tooltip';
        itemEl.style.cursor = 'pointer';
        itemEl.innerHTML = `
            ${itemData.name} (x${item.quantity})
            <span class="tooltiptext">${itemData.desc}</span>`;
        itemEl.onclick = () => useItem(index);
        elements.inventory.appendChild(itemEl);
    });
}

function updateDungeonMapUI() {
    elements.dungeonMap.innerHTML = '';
    if (state.roster.length === 0) {
        elements.dungeonMap.innerHTML = `<div class="small-muted" style="text-align:center;">Find a champion to explore the cursed lands.</div>`;
        return;
    }
    
    state.dungeon.map.forEach(node => {
        const nodeEl = document.createElement('div');
        nodeEl.className = `node ${node.locked ? 'locked' : ''} ${node.completed ? 'completed' : ''}`;
        if (state.dungeon.currentNode === node.id) {
            nodeEl.className += ' current';
        }
        nodeEl.innerHTML = `${node.icon} ${node.name}`;
        if (!node.locked && !node.completed) {
            nodeEl.onclick = () => selectNode(node.id);
        }
        elements.dungeonMap.appendChild(nodeEl);
    });
}

function updateBattleUI() {
    if (!state.activeEncounter) {
        elements.battleUI.style.display = 'none';
        elements.encounterInfo.textContent = 'The path ahead is quiet... for now.';
        return;
    }
    
    elements.battleUI.style.display = 'block';
    const enemy = state.activeEncounter.enemy;
    elements.encounterInfo.textContent = 'You are in combat!';
    elements.enemyName.textContent = enemy.name;
    
    let statusHTML = '';
    if (enemy.statusEffects && enemy.statusEffects.length > 0) {
        enemy.statusEffects.forEach(s => {
            statusHTML += `<span class="status-effect status-${s.type}">${s.type.toUpperCase()} (${s.duration})</span> `;
        });
    }

    const showHP = state.upgrades.find(u => u.id === 'scrying' && u.bought);
    const hpDisplay = showHP ? `HP: ${enemy.hp}/${enemy.maxHp} | ` : '';
    
    elements.enemyCard.innerHTML = `${hpDisplay}ATK: ${enemy.atk} <br> ${statusHTML}`;
    
    elements.battleActions.innerHTML = '';
    const champion = state.roster[0];
    champion.skills.forEach(skill => {
        const btn = document.createElement('button');
        btn.textContent = `${skill.name} (${skill.cost} Res)`;
        btn.disabled = champion.resolve < skill.cost || champion.hp <= 0;
        btn.onclick = () => playerTurn(skill);
        elements.battleActions.appendChild(btn);
    });
}

function updateUpgradesUI() {
    elements.upgrades.innerHTML = '';
    state.upgrades.forEach(u => {
        const upEl = document.createElement('div');
        upEl.className = 'upgrade';
        upEl.innerHTML = `
            <div>
                <strong>${u.name}</strong>
                <div class="small">${u.desc}</div>
            </div>
            <button ${state.essence < u.cost || u.bought ? 'disabled' : ''}>
                ${u.bought ? '‚úì Purchased' : `‚úíÔ∏è ${u.cost.toLocaleString()}`}
            </button>
        `;
        if (!u.bought) {
            upEl.querySelector('button').onclick = () => buyUpgrade(u.id);
        }
        elements.upgrades.appendChild(upEl);
    });
}

function updateLegacyUpgradesUI() {
    elements.legacyUpgrades.innerHTML = '';
    Object.entries(state.legacyUpgrades).forEach(([key, upgrade]) => {
        const upEl = document.createElement('div');
        upEl.className = 'legacy-upgrade tooltip';
        const cost = upgrade.cost + upgrade.level;
        upEl.innerHTML = `
            <strong>${upgrade.name}</strong><br>
            <div class="small">Level ${upgrade.level}</div>
            <button ${state.crownFragments < cost ? 'disabled' : ''} style="margin-top:5px;">
                üëë ${cost}
            </button>
            <span class="tooltiptext">${upgrade.desc}</span>
        `;
        if (state.crownFragments >= cost) {
            upEl.querySelector('button').onclick = () => buyLegacyUpgrade(key);
        }
        elements.legacyUpgrades.appendChild(upEl);
    });
}

function updateLoreUI() {
    if (state.loreUnlocked.length === 0) {
        elements.loreEntries.innerHTML = 'Discover lore scraps to piece together the world\'s history...';
        return;
    }
    
    elements.loreEntries.innerHTML = '';
    state.loreUnlocked.forEach((lore, index) => {
        const loreEl = document.createElement('div');
        loreEl.className = 'small';
        loreEl.style.marginBottom = '8px';
        loreEl.style.fontStyle = 'italic';
        loreEl.innerHTML = `<strong>Fragment ${index + 1}:</strong> ${lore}`;
        elements.loreEntries.appendChild(loreEl);
    });
}

function updateChronicleUI() {
    let chronicleText = "The ink is still wet on the first page...";
    
    if (state.roster.length > 0) {
        const champion = state.roster[0];
        const completed = state.dungeon.map.filter(n => n.completed).length;
        const total = state.dungeon.map.length;
        
        if (completed === 0) {
            chronicleText = `${champion.name} begins their journey into the cursed lands...`;
        } else if (completed < total - 1) {
            chronicleText = `${champion.name} has overcome ${completed} of ${total} trials...`;
        } else if (completed === total) {
            chronicleText = `${champion.name} stands before the Crown's final guardian...`;
        }
    }
    
    elements.chronicleText.textContent = chronicleText;
}

// --- CORE GAME LOGIC ---
function gather() {
    const baseGain = state.essencePerClick + (state.crownFragments * 0.5);
    state.essence += baseGain;
    
    // Small chance of finding lore while chronicling
    if (Math.random() < 0.05) {
        state.loreScraps += 1;
        log('You discover a fragment of ancient lore while chronicling!', 'success');
    }
    
    updateAllUI();
}

function recruit() {
    if (state.essence >= state.recruitCost && state.roster.length === 0) {
        state.essence -= state.recruitCost;
        const archetype = JSON.parse(JSON.stringify(championArchetypes[Math.floor(Math.random() * championArchetypes.length)]));
        
        // Apply legacy upgrades
        const healthBonus = state.legacyUpgrades.health.level * 15;
        const libraryBonus = state.upgrades.find(u => u.id === 'library' && u.bought) ? 10 : 0;
        
        archetype.maxHp += healthBonus + libraryBonus;
        archetype.hp = archetype.maxHp;
        archetype.statusEffects = [];
        
        state.roster.push(archetype);
        log(`You have found ${archetype.name}, a lost soul willing to fight.`, 'success');
        
        generateDungeon();
        updateAllUI();
    }
}

function buyUpgrade(id) {
    const up = state.upgrades.find(u => u.id === id);
    if (up && !up.bought && state.essence >= up.cost) {
        state.essence -= up.cost;
        up.bought = true;
        up.apply();
        log(`Upgraded Scriptorium: ${up.name}!`, 'success');
        updateAllUI();
    }
}

function buyLegacyUpgrade(key) {
    const upgrade = state.legacyUpgrades[key];
    const cost = upgrade.cost + upgrade.level;
    
    if (state.crownFragments >= cost) {
        state.crownFragments -= cost;
        upgrade.level++;
        
        // Apply immediate effects
        switch(key) {
            case 'essence':
                state.essencePerSec += 1;
                break;
        }
        
        log(`Legacy Enhanced: ${upgrade.name} Level ${upgrade.level}!`, 'purple');
        updateAllUI();
    }
}

// --- DUNGEON & ENCOUNTER LOGIC ---
function generateDungeon() {
    state.dungeon = { map: [], currentNodeId: null, floor: Math.floor((state.loops - 1) / 3) + 1 };
    
    const nodeTemplates = [
        { name: 'Cursed Grove', icon: 'üå≤', type: 'combat' },
        { name: 'Abandoned Outpost', icon: 'üèöÔ∏è', type: 'combat' },
        { name: 'Spectral Battleground', icon: '‚öîÔ∏è', type: 'combat' },
        { name: 'Ancient Campfire', icon: 'üî•', type: 'rest' },
        { name: 'Hidden Cache', icon: 'üíé', type: 'treasure' },
        { name: 'Meditation Circle', icon: 'üßò', type: 'rest' },
        { name: 'Ruined Shrine', icon: 'üèõÔ∏è', type: 'event' },
        { name: 'Crystal Cave', icon: 'üí†', type: 'treasure' },
        { name: 'Shadow Portal', icon: 'üåÄ', type: 'elite' },
        { name: 'Bone Garden', icon: 'üíÄ', type: 'elite' }
    ];
    
    // Generate 8-10 nodes
    const nodeCount = 8 + Math.floor(Math.random() * 3);
    const selectedTemplates = [];
    
    // Ensure at least one of each important type
    selectedTemplates.push(
        nodeTemplates.find(t => t.type === 'rest'),
        nodeTemplates.find(t => t.type === 'treasure'),
        nodeTemplates.find(t => t.type === 'elite')
    );
    
    // Fill rest randomly
    while (selectedTemplates.length < nodeCount - 1) {
        const template = nodeTemplates[Math.floor(Math.random() * nodeTemplates.length)];
        selectedTemplates.push(JSON.parse(JSON.stringify(template)));
    }
    
    // Shuffle
    for (let i = selectedTemplates.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [selectedTemplates[i], selectedTemplates[j]] = [selectedTemplates[j], selectedTemplates[i]];
    }
    
    // Create nodes
    selectedTemplates.forEach((template, i) => {
        state.dungeon.map.push({
            id: i,
            ...template,
            locked: i > 0,
            completed: false
        });
    });
    
    // Add final boss
    state.dungeon.map.push({ 
        id: selectedTemplates.length, 
        name: 'Crown\'s Sanctum', 
        icon: 'üëë', 
        type: 'boss', 
        locked: true, 
        completed: false 
    });
    
    updateDungeonMapUI();
}

function selectNode(id) {
    const node = state.dungeon.map.find(n => n.id === id);
    if (node.completed || node.locked) return;

    state.dungeon.currentNode = id;
    log(`You approach the ${node.name}.`);

    switch (node.type) {
        case 'combat':
            const enemyType = Math.random() < 0.7 ? 'husk' : Math.random() < 0.8 ? 'wight' : 'sentinel';
            startEncounter(enemies[enemyType], id);
            break;
        case 'elite':
            const eliteType = Math.random() < 0.6 ? 'wight' : 'sentinel';
            startEncounter(enemies[eliteType], id);
            break;
        case 'boss':
            startEncounter(enemies.echo, id);
            break;
        case 'rest':
            handleRestSite(node);
            break;
        case 'treasure':
            handleTreasure(node);
            break;
        case 'event':
            triggerRandomEvent();
            break;
    }
    updateAllUI();
}

function handleRestSite(node) {
    node.completed = true;
    unlockNextNode(node.id);
    
    const champion = state.roster[0];
    const hpHealed = Math.floor(champion.maxHp * 0.6);
    const resolveHealed = Math.floor(champion.maxResolve * 0.8);
    
    champion.hp = Math.min(champion.maxHp, champion.hp + hpHealed);
    champion.resolve = Math.min(champion.maxResolve, champion.resolve + resolveHealed);
    
    // Clear negative status effects
    if (champion.statusEffects) {
        champion.statusEffects = champion.statusEffects.filter(s => s.type === 'shielded');
    }
    
    log(`You rest peacefully, recovering ${hpHealed} HP and ${resolveHealed} Resolve.`, 'success');
}

function handleTreasure(node) {
    node.completed = true;
    unlockNextNode(node.id);
    
    const itemPool = ['potion', 'draught', 'elixir', 'antidote', 'bomb'];
    const foundItemId = itemPool[Math.floor(Math.random() * itemPool.length)];
    const quantity = Math.random() < 0.3 ? 2 : 1;
    
    addItem(foundItemId, quantity);
    log(`You found ${quantity}x ${items[foundItemId].name}!`, 'success');
    
    // Bonus essence
    const bonusEssence = 15 + Math.floor(Math.random() * 20);
    state.essence += bonusEssence;
    log(`You also gain ${bonusEssence} Temporal Essence from the site's residual magic.`);
}

function unlockNextNode(currentId) {
    if (currentId + 1 < state.dungeon.map.length) {
        state.dungeon.map[currentId + 1].locked = false;
    }
}

function startEncounter(enemyTemplate, nodeId) {
    const enemy = JSON.parse(JSON.stringify(enemyTemplate));
    
    // Scale enemy with floor
    const floorMultiplier = 1 + (state.dungeon.floor - 1) * 0.3;
    enemy.hp = Math.floor(enemy.hp * floorMultiplier);
    enemy.maxHp = enemy.hp;
    enemy.atk = Math.floor(enemy.atk * floorMultiplier);
    
    state.activeEncounter = {
        nodeId: nodeId,
        enemy: enemy,
    };
    
    log(`A ${enemy.name} emerges from the shadows!`, 'danger');
    updateAllUI();
}

function playerTurn(skill) {
    const champion = state.roster[0];
    const enemy = state.activeEncounter.enemy;
    
    if (champion.resolve < skill.cost || champion.hp <= 0) return;
    
    champion.resolve -= skill.cost;
    log(`${champion.name} uses ${skill.name}!`);
    
    // Apply damage multiplier from legacy upgrades
    const oldEffect = skill.effect;
    skill.effect = function(enemy, user) {
        oldEffect.call(this, enemy, user);
        // Apply damage bonus if this was an attack
        if (skill.name.includes('Strike') || skill.name.includes('Shot') || skill.name.includes('Bash') || skill.name.includes('Bolt')) {
            const damageBonus = Math.floor(state.legacyUpgrades.damage.level * 0.2 * (15 + (user.level - 1) * 3));
            if (damageBonus > 0) {
                enemy.hp -= damageBonus;
                log(`Legacy power adds ${damageBonus} damage!`);
            }
        }
    };
    
    skill.effect(enemy, champion);
    
    // Process champion status effects
    processStatusEffects(champion);
    
    if (!checkBattleEnd()) {
        setTimeout(enemyTurn, 800);
    }
    updateAllUI();
}

function enemyTurn() {
    if (!state.activeEncounter) return;
    
    const champion = state.roster[0];
    const enemy = state.activeEncounter.enemy;
    
    if (processStatusEffects(enemy)) {
        checkBattleEnd();
        updateAllUI();
        return;
    }

    const move = enemy.skills[Math.floor(Math.random() * enemy.skills.length)];
    
    if (move.type === 'attack') {
        let damage = enemy.atk;
        
        // Check if enemy is weakened
        if (enemy.statusEffects?.some(s => s.type === 'weakened')) {
            damage = Math.floor(damage * 0.7);
        }
        
        // Check if champion is shielded
        if (champion.statusEffects?.some(s => s.type === 'shielded')) {
            damage = Math.floor(damage * 0.5);
            log(`${champion.name}'s shield absorbs half the damage!`);
        }
        
        champion.hp -= damage;
        log(`${enemy.name} attacks for ${damage} damage.`, 'danger');
    } else if (move.type === 'special') {
        move.effect.call(enemy, champion);
    }

    checkBattleEnd();
    updateAllUI();
}

function checkBattleEnd() {
    if (!state.activeEncounter) return false;
    
    const champion = state.roster[0];
    const enemy = state.activeEncounter.enemy;
    const nodeId = state.activeEncounter.nodeId;

    if (enemy.hp <= 0) {
        log(`You have defeated the ${enemy.name}!`, 'success');
        
        // Mark node as completed and unlock next
        const completedNode = state.dungeon.map.find(n => n.id === nodeId);
        if (completedNode) {
            completedNode.completed = true;
            unlockNextNode(nodeId);
            
            if (completedNode.type === 'boss') {
                log('The Crown\'s power weakens! You can now attempt to Shatter it.', 'purple');
            }
        }
        
        // Rewards
        const baseEssence = 25 + Math.floor(Math.random() * 15);
        const baseLore = 1 + (state.upgrades.find(u => u.id === 'binding' && u.bought) ? 1 : 0) + state.legacyUpgrades.lore.level;
        const experience = 20 + Math.floor(Math.random() * 15);
        
        state.essence += baseEssence;
        state.loreScraps += baseLore;
        state.victories += 1;
        
        // Champion gains experience
        champion.experience += experience * (state.upgrades.find(u => u.id === 'wisdom' && u.bought) ? 1.5 : 1);
        checkLevelUp(champion);
        
        // Increase bond
        champion.bond = Math.min(champion.maxBond, champion.bond + 5);
        
        log(`Gained: ${baseEssence} Essence, ${baseLore} Lore Scraps, ${experience} Experience`);
        
        // Random item drop
        if (Math.random() < 0.3) {
            const itemPool = Object.keys(items);
            const foundItem = itemPool[Math.floor(Math.random() * itemPool.length)];
            addItem(foundItem, 1);
            log(`Found: ${items[foundItem].name}!`, 'success');
        }
        
        // Discover lore
        if (Math.random() < 0.2) {
            const loreFragments = [
                "The Crown was forged in the heart of a dying star, binding the fate of worlds to its will.",
                "Ancient texts speak of a time before the curse, when heroes walked freely across the realms.",
                "The Ashen Crown's power grows with each cycle, feeding on the despair of those trapped within.",
                "Legends tell of a way to break the cycle, but the knowledge has been lost to time.",
                "Each champion who falls becomes part of the Crown's eternal guard, doomed to serve forever.",
                "The Chronicler's role is not to change fate, but to record it - yet some believe this very act can alter destiny.",
                "In the deepest chambers of the Crown's sanctum, echoes of past victories still resonate with hope.",
                "The curse began when the last true king refused to accept his mortality, binding his soul to the Crown."
            ];
            const newLore = loreFragments[Math.floor(Math.random() * loreFragments.length)];
            if (!state.loreUnlocked.includes(newLore)) {
                state.loreUnlocked.push(newLore);
                log(`You discover ancient lore: "${newLore}"`, 'purple');
            }
        }
        
        state.activeEncounter = null;
        updateAllUI();
    } else if (champion.hp <= 0) {
        log(`${champion.name} has fallen! The cycle claims another victim.`, 'danger');
        state.roster = [];
        state.activeEncounter = null;
        state.dungeon = { map: [], currentNode: null, floor: 1 };
        updateAllUI();
    }
    
    return champion.hp <= 0 || enemy.hp <= 0;
}

function processStatusEffects(target) {
    if (!target.statusEffects || target.statusEffects.length === 0) return false;
    
    let died = false;
    target.statusEffects = target.statusEffects.filter(status => {
        status.duration--;
        
        switch (status.type) {
            case 'poison':
                const poisonDamage = Math.floor(target.maxHp * 0.1);
                target.hp -= poisonDamage;
                log(`${target.name} takes ${poisonDamage} poison damage!`, 'danger');
                break;
            case 'bleeding':
                const bleedDamage = Math.floor(target.maxHp * 0.15);
                target.hp -= bleedDamage;
                log(`${target.name} bleeds for ${bleedDamage} damage!`, 'danger');
                break;
            case 'stunned':
                log(`${target.name} is stunned and cannot act!`);
                return false; // Skip this turn
        }
        
        if (target.hp <= 0) died = true;
        return status.duration > 0;
    });
    
    return died;
}

function applyStatus(target, type, duration) {
    if (!target.statusEffects) target.statusEffects = [];
    
    // Remove existing status of same type
    target.statusEffects = target.statusEffects.filter(s => s.type !== type);
    
    target.statusEffects.push({ type, duration });
}

function checkLevelUp(champion) {
    const expNeeded = champion.level * 100;
    if (champion.experience >= expNeeded) {
        champion.experience -= expNeeded;
        champion.level++;
        
        // Level up bonuses
        const hpGain = 10 + Math.floor(champion.level * 2);
        const resolveGain = 5 + Math.floor(champion.level * 1.5);
        
        champion.maxHp += hpGain;
        champion.hp += hpGain;
        champion.maxResolve += resolveGain;
        champion.resolve += resolveGain;
        
        log(`${champion.name} reaches level ${champion.level}! +${hpGain} HP, +${resolveGain} Resolve`, 'success');
        
        // Check for more level ups
        checkLevelUp(champion);
    }
}

function addItem(itemId, quantity = 1) {
    const existing = state.inventory.find(item => item.id === itemId);
    if (existing) {
        existing.quantity += quantity;
    } else {
        state.inventory.push({ id: itemId, quantity });
    }
}

function useItem(index) {
    if (!state.activeEncounter || index >= state.inventory.length) return;
    
    const item = state.inventory[index];
    const itemData = items[item.id];
    const champion = state.roster[0];
    
    if (itemData.use) {
        itemData.use(champion, state.activeEncounter.enemy);
        item.quantity--;
        
        if (item.quantity <= 0) {
            state.inventory.splice(index, 1);
        }
        
        updateAllUI();
    }
}

function triggerRandomEvent() {
    if (state.activeEvent) return;
    
    const event = randomEvents[Math.floor(Math.random() * randomEvents.length)];
    state.activeEvent = event;
    
    elements.eventDialog.style.display = 'block';
    elements.eventText.textContent = event.text;
    elements.eventChoices.innerHTML = '';
    
    event.choices.forEach((choice, index) => {
        const btn = document.createElement('button');
        btn.textContent = choice.text;
        btn.onclick = () => handleEventChoice(index);
        elements.eventChoices.appendChild(btn);
    });
}

function handleEventChoice(choiceIndex) {
    const event = state.activeEvent;
    const choice = event.choices[choiceIndex];
    
    // Check costs
    let canAfford = true;
    if (choice.cost) {
        if (choice.cost.essence && state.essence < choice.cost.essence) canAfford = false;
        if (choice.cost.resolve && state.roster.length > 0 && state.roster[0].resolve < choice.cost.resolve) canAfford = false;
    }
    
    if (!canAfford) {
        log("You cannot afford this choice.", 'danger');
        return;
    }
    
    // Pay costs
    if (choice.cost) {
        if (choice.cost.essence) state.essence -= choice.cost.essence;
        if (choice.cost.resolve && state.roster.length > 0) state.roster[0].resolve -= choice.cost.resolve;
    }
    
    // Apply rewards
    if (choice.reward) {
        if (choice.reward.essence) state.essence += choice.reward.essence;
        if (choice.reward.lore) state.loreScraps += choice.reward.lore;
        if (choice.reward.experience && state.roster.length > 0) {
            state.roster[0].experience += choice.reward.experience;
            checkLevelUp(state.roster[0]);
        }
        if (choice.reward.championHeal && state.roster.length > 0) {
            const champion = state.roster[0];
            const healing = Math.floor(champion.maxHp * choice.reward.championHeal);
            champion.hp = Math.min(champion.maxHp, champion.hp + healing);
            log(`${champion.name} recovers ${healing} HP.`, 'success');
        }
        if (choice.reward.item) {
            if (choice.reward.item === 'random') {
                const itemPool = Object.keys(items);
                const randomItem = itemPool[Math.floor(Math.random() * itemPool.length)];
                addItem(randomItem, 1);
                log(`You receive: ${items[randomItem].name}!`, 'success');
            } else {
                addItem(choice.reward.item, 1);
                log(`You receive: ${items[choice.reward.item].name}!`, 'success');
            }
        }
    }
    
    log(`Event: ${event.title} - ${choice.text}`, 'info');
    
    elements.eventDialog.style.display = 'none';
    state.activeEvent = null;
    updateAllUI();
}

function canPrestige() {
    return state.dungeon.map.length > 0 && 
           state.dungeon.map.every(node => node.completed) && 
           state.roster.length > 0;
}

function prestige() {
    if (!canPrestige()) return;
    
    const champion = state.roster[0];
    const fragmentsGained = Math.floor(state.victories * 0.1) + Math.floor(state.loreScraps * 0.05) + 1;
    
    state.crownFragments += fragmentsGained;
    state.loops++;
    
    log(`The Crown shatters! You gain ${fragmentsGained} Crown Fragments and begin cycle ${state.loops}.`, 'purple');
    
    // Reset for new cycle
    state.roster = [];
    state.inventory = [];
    state.dungeon = { map: [], currentNode: null, floor: 1 };
    state.activeEncounter = null;
    state.activeEvent = null;
    state.essence = 0;
    state.loreScraps = 0;
    state.victories = 0;
    
    // Increase recruit cost
    state.recruitCost = Math.floor(state.recruitCost * 1.5);
    
    updateAllUI();
}

// --- SAVE/LOAD SYSTEM ---
function saveGame() {
    const saveData = {
        ...state,
        timestamp: Date.now()
    };
    localStorage.setItem('moonbound_save', JSON.stringify(saveData));
    log('Game saved successfully!', 'success');
}

function loadGame() {
    const saveData = localStorage.getItem('moonbound_save');
    if (saveData) {
        try {
            state = JSON.parse(saveData);
            log('Game loaded successfully!', 'success');
            updateAllUI();
        } catch (e) {
            log('Failed to load save data.', 'danger');
        }
    }
}

function exportData() {
    const saveData = {
        ...state,
        timestamp: Date.now()
    };
    const dataStr = JSON.stringify(saveData, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `moonbound_save_${new Date().toISOString().split('T')[0]}.json`;
    link.click();
    URL.revokeObjectURL(url);
    log('Save data exported!', 'success');
}

function importData() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const saveData = JSON.parse(e.target.result);
                    state = saveData;
                    log('Save data imported successfully!', 'success');
                    updateAllUI();
                } catch (err) {
                    log('Failed to import save data.', 'danger');
                }
            };
            reader.readAsText(file);
        }
    };
    input.click();
}

// --- MENU FUNCTIONS ---
function startNewGame() {
    state = getNewGameState();
    elements.mainMenu.style.display = 'none';
    elements.gameContainer.style.display = 'block';
    initGame();
    log('A new chronicle begins...', 'info');
}

function showMainMenu() {
    elements.mainMenu.style.display = 'flex';
    elements.gameContainer.style.display = 'none';
}

function showHelp() {
    const helpText = `Moonbound: Echoes of the Ashen Crown

HOW TO PLAY:
‚Ä¢ Click "Chronicle Events" to gather Temporal Essence
‚Ä¢ Use Essence to recruit Champions and upgrade your Scriptorium
‚Ä¢ Guide your Champion through the Cursed Lands
‚Ä¢ Complete all nodes to face the Crown's Echo
‚Ä¢ Shatter the Crown to gain Crown Fragments and start a new cycle
‚Ä¢ Use Crown Fragments for permanent Legacy Upgrades

COMBAT:
‚Ä¢ Use your Champion's skills to defeat enemies
‚Ä¢ Manage Resolve (mana) and HP carefully
‚Ä¢ Use items from your inventory during combat
‚Ä¢ Status effects can help or hinder you

KEYBOARD SHORTCUTS:
‚Ä¢ G - Chronicle Events (gather essence)
‚Ä¢ R - Recruit Champion (when available)
‚Ä¢ Ctrl+S - Save Game

GOAL:
Break the endless cycle by growing powerful enough to permanently destroy the Ashen Crown!

DEBUG:
‚Ä¢ Open browser console and type debugState() to see current game state`;

    // Create a modal dialog instead of alert
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; align-items: center;
        justify-content: center; z-index: 1000;
    `;
    
    const content = document.createElement('div');
    content.style.cssText = `
        background: var(--panel); padding: 30px; border-radius: 15px;
        max-width: 600px; max-height: 80vh; overflow-y: auto;
        border: 2px solid var(--accent); color: #efece6;
        font-family: Georgia, serif; line-height: 1.6;
    `;
    
    content.innerHTML = `
        <h2 style="color: var(--accent); margin-top: 0;">${helpText.replace(/\n/g, '<br>')}</h2>
        <button onclick="this.parentElement.parentElement.remove()" 
                style="background: var(--accent); border: none; padding: 10px 20px; 
                       border-radius: 8px; color: #241305; font-weight: bold; cursor: pointer; margin-top: 20px;">
            Close
        </button>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // Close on click outside
    modal.onclick = (e) => {
        if (e.target === modal) modal.remove();
    };
}

function initGame() {
    try {
        updateAllUI();
        
        // Add some initial lore if starting fresh
        if (state.loreUnlocked.length === 0) {
            state.loreUnlocked.push("The Chronicler's duty is to record the endless cycles, but perhaps this very act can change fate itself.");
        }
        
        console.log('Game initialized with state:', state);
    } catch (error) {
        console.error('Error in initGame:', error);
    }
}

function log(message, type = 'info') {
    if (!elements.eventLog) {
        console.log(`[${type.toUpperCase()}] ${message}`);
        return;
    }
    
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement('div');
    logEntry.className = `small ${type}`;
    logEntry.textContent = `[${timestamp}] ${message}`;
    
    elements.eventLog.appendChild(logEntry);
    elements.eventLog.scrollTop = elements.eventLog.scrollHeight;
    
    // Limit log entries
    while (elements.eventLog.children.length > 100) {
        elements.eventLog.removeChild(elements.eventLog.firstChild);
    }
}

// Utility function for debugging
function debugState() {
    console.log('Current game state:', {
        essence: state.essence,
        loreScraps: state.loreScraps,
        loops: state.loops,
        crownFragments: state.crownFragments,
        roster: state.roster.length,
        inventory: state.inventory.length,
        dungeon: state.dungeon.map.length,
        activeEncounter: !!state.activeEncounter,
        activeEvent: !!state.activeEvent
    });
}

// Add keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if (elements.gameContainer.style.display === 'block') {
        switch(e.key) {
            case 'g':
            case 'G':
                if (!e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    gather();
                }
                break;
            case 'r':
            case 'R':
                if (!e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    if (state.roster.length === 0 && state.essence >= state.recruitCost) {
                        recruit();
                    }
                }
                break;
            case 's':
            case 'S':
                if (e.ctrlKey) {
                    e.preventDefault();
                    saveGame();
                }
                break;
        }
    }
});

// Initialize the game when the page loads
document.addEventListener('DOMContentLoaded', () => {
    try {
        // Check for existing save
        if (localStorage.getItem('moonbound_save')) {
            if (elements.loadBtn) {
                elements.loadBtn.disabled = false;
            }
        }
        
        // Initialize state if not already done
        if (!state) {
            state = getNewGameState();
        }
        
        console.log('Moonbound game initialized successfully');
    } catch (error) {
        console.error('Error initializing game:', error);
    }
});
</script>
</body>
</html>
